#phys sciences sociales v5

from PyProbs import Probability as pr
import numpy as np
import matplotlib.pyplot as plt
import random as rd
from math import floor
from math import ceil
from math import exp


##fonction utiles
def fpbarre(p, Y, t):
    somme1=0
    somme2=0
    for i in range (len(p)):
        somme1=somme1+p[i][t]*Y[i][t]
        somme2=somme2+Y[i][t]
    if somme2!=0:
        return (somme1/somme2)
    else:
        return (somme1)

def workforcemax(beta, w, wbarre, t, Nf, i,u):
    haut=exp(beta*w[i][t]/wbarre[t])*Nf*u[t]
    bas=0
    for k in range (len(w)):
        bas=bas+exp(beta*w[k][t]/wbarre[t])
    return (haut/bas)

def fwbarre(w, Y, t):
    somme1=0
    somme2=0
    for i in range (len(w)):
        somme1=somme1+w[i][t]*Y[i][t]
        somme2=somme2+Y[i][t]
    if somme2!=0:
        return (somme1/somme2)
    else:
        return (somme1)
#remarque on peut faire pbarre(w,Y,t) car c'est la même fonction... à voir si on conserve les deux

def chomage(t, Nf, L):
    somme=0
    for i in range (Nf):
        somme=somme+L[i][t]
    return (1-somme/Nf)

#Li est le nombre d'employés de la firme i

def sommeeps(en_dette, epsilon,t):
    somme=0
    for i in range (len(espilon)):
        if i in en_dette:
            somme=somme+min(epsilon[i][t], 0)
    return (somme)

def somme2eps(V, Y, w):
    somme=0
    if len(V)>0:
        for j in (len(V)):
            somme=somme+Y[V[j]][t]*w[V[j]][t]
    else:
        somme=0
    return (somme)

def fonction(epsilon, espilond, H, Nf,i,t):
    res=(epsilond[t]-H[t])*epsilon[i][t]
    res2=0
    for i in range (Nf):
        res2=res2+max(epsilon[i][t], 0)
    return (res/res2)

def somme0(Nf, Y, w,t):
    res=0
    for i in range (Nf):
        res=res+Y[i][t]*w[i][t]
    return (res)

def somme1(div,t):
    res=0
    for i in range (len(div)):
        res=res+div[i][t]
    return (res)

def calculz(beta, p, pbarre, t):
    res=0
    for i in range (len(p)):
        res=res+exp(-beta*p[i][t]/pbarre[t])
    return(res)

def calculdeC(p, Y, D, Nf,t):
    res=0
    for i in range (Nf):
        res=res+p[i][t]*min(Y[i][t], D[i][t])
    return (res)

##déroulé
def  fonctionfinale(Nf, c, beta, gamma, etamoins, etaplus, delta, teta, psi, zeta, temps ): #perturbation est couple [debut, fin, intensité]-> on rajoutera plus tard
    #définition des fonctions
    pbarre=np.ones(temps)
    wbarre=np.ones(temps)
    xi=np.zeros((Nf,temps))
    umax=np.zeros((Nf, temps))
    u=np.zeros(temps)
    Y=np.zeros((Nf, temps+1))
    D=np.zeros((Nf, temps))
    p=np.zeros((Nf, temps+1))
    div=np.zeros((Nf, temps))
    epsilon=np.zeros((Nf, temps+1))
    phi=np.zeros((Nf, temps))
    w=np.zeros((Nf, temps))
    en_dette=[]
    epsilond=np.zeros( temps )
    V=[]
    H=np.zeros(temps+1)
    Cb=np.zeros(temps)
    Z=np.zeros(temps)
    C=np.zeros(temps)
    prof=np.zeros((Nf, temps))
    L=np.zeros((Nf, temps))
    #conditions initales à vérifier cohérence
    pbarre[0]=1
    wbarre[0]=1
    H[0]=0
    Cb[0]=0
    Z[0]=Nf*exp(-beta)
    C[0]=0

    epsilond[0]=0
    for i in range (Nf):
        xi[i][0]=0
        Y[i][0]=1
        Y[i][1]=1+etaplus*(D[i][0]-Y[i][0])
        D[i][0]=0
        p[i][0]=1
        prof[i][0]=0
        div[i][0]=0
        epsilon[i][0]=0
        phi[i][0]=0

        for t in range (temps):
            w[i][t]=1
    for i in range (Nf):
        umax[i][0]=workforcemax(beta, w, wbarre, 0, Nf, i, u)
        L[i][0]=rd.random() #le nombre de gens dans la firme i qui sont réellement employés
    u[0]=chomage(0, Nf, L)
    for t in range (1, temps):
        pbarre[t]=fpbarre(p, Y, t)
        wbarre[t]=fwbarre(w, Y, t)
        for i in range (Nf):
            xi[i][t]=rd.random()
            umax[i][t]=workforcemax(beta, w, wbarre, t-1, Nf, i, u)
            u[t]=1-chomage(t-1, Nf, L)
            if Y[i][t]<D[i][t]:
                Y[i][t+1]=Y[i][t] + min (etaplus*(D[i][t]-Y[i][t]), umax[i][t])
                if p[i][t]<pbarre[t]:
                    p[i][t+1]=p[i][t](1+gamma*xi[i][t])
                else:
                    p[i][t+1]=p[i][t]
            else:
                Y[i][t+1]=Y[i][t] + max(etamoins*(D[i][t]-Y[i][t]), 0)
                if p[i][t]<=pbarre[t]:
                    p[i][t+1]=p[i][t]
                else:
                    p[i][t+1]=p[i][t](1-gamma*xi[i][t])

            if i not in en_dette:
                Y[i][t]=Y[i][t]+zeta*L[i][t] #production

                prof[i][t]=p[i][t]*min(Y[i][t], D[i][t])-zeta*L[i][t]*w[i][t] #profit

                if prof[i][t]>=0 and epsilon[i][t]>=0:
                    div[i][t]=delta*epsilon[i][t]
                    epsilon[i][t+1]=epsilon[i][t]+prof[i][t]-div[i][t]

                if epsilon[i][t]<0:
                    phi[i][t]=-epsilon[i][t]/(Y[i][t]*w[i][t])

                if phi[i][t]>teta:
                    en_dette.append[i] #on dit qui est ruiné
                    epsilond[t]=epsilond[t]-sommeeps(en_dette, epsilon)
                    epsilon[i][t]=0
                    u[t+1]=u[t+1]+L[i][t] #on dit qui est au chômage
                    L[i][t+1]=0 #plus personne dans l'entreprise

            else:
                #on tire avec proba psi dans les interdits pour qui on revit et on update V
                for i in range (len(en_dette)):
                    test=pr.Prob(psi)
                    if test==True:
                        V.append(en_dette[i])
                        del en_dette[i] #il n'est plus endetté car on on a eu TRUE
                epsilond[t]=epsilond[t]+somme2eps(V, Y, w)

        if epsilond[t]<=H[t]:
            H[t+1]=H[t]-epsilond[t]
        else:
            H[t+1]=0
            epsilon[i][t+1]=epsilon[i][t] - H[t] -fonction(epsilon, espilond, H, Nf, i, t)


        Cb[t]=c*(H[t]+somme0(Nf, Y, w,t))

        Z[t]=calculz(beta, p, pbarre, t)

        for i in range (Nf):
            if Z[t]!=0 and pbarre[t]!=0:
                D[i][t]=Cb[t]*exp(-beta*p[i][t]/pbarre[t])/(p[i][t]*Z[t])
            else:
                D[i][t]=0

        C[t]=calculdeC(p, Y, D, Nf,t)

        H[t+1]=H[t+1]+somme0(Nf, Y, w,t) + somme1(div,t)-C[t] # H représente S les savings

    return (u)



#testée et approuvée : fonctionfinale(1000, 0.5, 2, 0.01, 0.2, 0.4, 0.02, 3, 0.1, 1, 3)

##avec perturbation maintenant

def avecperturbation(Nf, c, beta, gamma, etamoins, etaplus, delta, teta, psi, zeta, temps, perturbation ): #perturbation est couple [debut, fin, intensité]-> on rajoutera plus tard
    #définition des fonctions
    debut=perturbation[0]
    fin=perturbation[1]
    valeurdec=[c, perturbation[2]]
    zetainit=zeta
    pbarre=np.ones(temps)
    wbarre=np.ones(temps)
    xi=np.zeros((Nf,temps))
    umax=np.zeros((Nf, temps))
    u=np.zeros(temps)
    Y=np.zeros((Nf, temps+1))
    D=np.zeros((Nf, temps))
    p=np.zeros((Nf, temps+1))
    div=np.zeros((Nf, temps))
    epsilon=np.zeros((Nf, temps+1))
    phi=np.zeros((Nf, temps))
    w=np.zeros((Nf, temps))
    en_dette=[]
    epsilond=np.zeros( temps )
    V=[]
    H=np.zeros(temps+1)
    Cb=np.zeros(temps)
    Z=np.zeros(temps)
    C=np.zeros(temps)
    prof=np.zeros((Nf, temps))
    L=np.zeros((Nf, temps))
    #conditions initales à vérifier cohérence
    pbarre[0]=1
    wbarre[0]=1
    u[0]=0
    H[0]=0
    Cb[0]=0
    Z[0]=Nf*exp(-beta)
    C[0]=0
    epsilond[0]=0
    for i in range (Nf):
        xi[i][0]=0
        Y[i][0]=1
        D[i][0]=0
        p[i][0]=1
        prof[i][0]=0
        div[i][0]=0
        epsilon[i][0]=0
        phi[i][0]=0

        for t in range (temps):
            w[i][t]=1 #le wage
    for i in range (Nf):
        umax[i][0]=100*rd.random() #nombre d'employés max au début dans chaque firme
        L[i][0]=umax[i][0] #le nombre de gens dans la firme i qui sont réellement employés car on suppose au début plein emploi
    for t in range (1, temps):
        if debut<=t<=fin:
            c=valeurdec[1]
            zeta=zetainit/2
        else:
            c=valeurdec[0]
            zeta=zetainit
        pbarre[t]=fpbarre(p, Y, t)
        wbarre[t]=fwbarre(w, Y, t)
        for i in range (Nf):
            xi[i][t]=rd.random()
            umax[i][t]=workforcemax(beta, w, wbarre, t, Nf, i, u)
            u[t]=1-chomage(t, Nf, L)
            if Y[i][t]<D[i][t]:
                Y[i][t+1]=Y[i][t] + min (etaplus*(D[i][t]-Y[i][t]), umax[i][t])
                if p[i][t]<pbarre[t]:
                    p[i][t+1]=p[i][t](1+gamma*xi[i][t])
                else:
                    p[i][t+1]=p[i][t]
            else:
                Y[i][t+1]=Y[i][t] + max(etamoins*(D[i][t]-Y[i][t]), 0)
                if p[i][t]<=pbarre[t]:
                    p[i][t+1]=p[i][t]
                else:
                    p[i][t+1]=p[i][t](1-gamma*xi[i][t])

            if i not in en_dette:
                Y[i][t]=zeta*L[i][t] #production

                prof[i][t]=p[i][t]*min(Y[i][t], D[i][t])-Y[i][t] #profit

                if prof[i][t]>=0 and epsilon[i][t]>=0:
                    div[i][t]=delta*epsilon[i][t]
                    epsilon[i][t+1]=epsilon[i][t]+prof[i][t]-div[i][t]

                if epsilon[i][t]<0:
                    phi[i][t]=-epsilon[i][t]/(Y[i][t]*w[i][t])

                if phi[i][t]>teta:
                    en_dette.append[i] #on dit qui est ruiné
                    epsilond[t]=epsilond[t]-sommeeps(en_dette, epsilon)
                    epsilon[i][t]=0
                    u[t]=u[t]+L[i][t] #on dit qui est au chômage
                    L[i][t]=0 #plus personne dans l'entreprise

            else:
                #on tire avec proba psi dans les interdits pour qui on revit et on update V
                for i in range (len(en_dette)):
                    test=pr.Prob(psi)
                    if test==True:
                        V.append(en_dette[i])
                        del en_dette[i] #il n'est plus endetté car on on a eu TRUE
                epsilond[t]=epsilond[t]+somme2eps(V, Y, w)

        if epsilond[t]<=H[t]:
            H[t+1]=H[t]-epsilond[t]
        else:
            H[t+1]=0
            epsilon[i][t+1]=epsilon[i][t] - H[t] -fonction(epsilon, espilond, H, Nf, i, t)


        Cb[t]=c*(H[t]+somme0(Nf, Y, w,t))

        Z[t]=calculz(beta, p, pbarre, t)

        for i in range (Nf):
            if Z[t]!=0 and pbarre[t]!=0:
                D[i][t]=Cb[t]*exp(-beta*p[i][t]/pbarre[t])/(p[i][t]*Z[t])
            else:
                D[i][t]=0

        C[t]=calculdeC(p, Y, D, Nf,t)

        H[t+1]=H[t+1]+somme0(Nf, Y, w,t) + somme1(div,t)-C[t] # H représente S les savings

    return (Y)


